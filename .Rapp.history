library(doMC)#
library(fields)#
library(gdistance)#
library(geometry)#
library(ks)#
library(lubridate)#
library(maptools)#
library(OpenStreetMap)#
library(raster)#
library(RColorBrewer)#
library(rgdal)#
library(rgeos)#
library(sampSurf)#
library(seraphim)#
library(sp)#
library(spatstat)#
#
# A. Preparing the environmental data#
	# A.1. Defining the projections and extents#
	# A.2. Loading the rasters and shapefiles#
	# A.3. Uniformising the different projections#
	# A.4. Generating the overall European map#
# B. Analysing the GPS collar data#
	# B.1. Loading the GPS collar traces#
	# B.2. Visualising the GPS traces on OpenStreetMap#
	# B.3. Extracting environmental values and distances#
	# B.4. Analyses of the impact of factors on movement velocity#
	# B.5. Analysis of the time proportion spent in non-forest areas#
	# B.6. Estimating the frequency of crossing motorway events#
# C. Analysing the occurrence data#
	# C.1. Loading and preparing the reported cases#
	# C.2. Subsetting the data based on kernel densities#
	# C.3. Estimating and plotting the wavefront velocities#
		# C.3.1. Defining the analysis mask#
		# C.3.2. Interpolation of first time of invasion#
		# C.3.3. Estimating the friction and spread rate#
		# C.3.4. Estimating the spread rate#
		# C.3.5. Plotting the resulting rasters#
	# C.4. Investigating the impact of environmental factors on the dispersal#
		# C.4.1. Analysing the impact of factors on the wavefront dispersal velocity#
		# C.4.2. Analysis of the impact of barriers on the dispersal frequency#
showingPlots = FALSE#
#
# A. Preparing the environmental data#
#
	# A.1. Defining the projections and extents#
#
wgs84 = CRS("+init=epsg:4326")#
lambert72 = CRS("+init=epsg:31370")#
lambert93 = CRS("+init=epsg:2154")#
e1_lam93 = extent(760000, 950000, 6910000, 7080000)#
e1_temp = as(e1_lam93, "SpatialPolygons")#
sp::proj4string(e1_temp) = lambert93#
e1_temp = sp::spTransform(e1_temp, wgs84)#
e1_wgs84 = extent(e1_temp)#
e2_lam93 = extent(865000, 911000, 6935700, 6975000)#
e2_temp = as(e2_lam93, "SpatialPolygons")#
sp::proj4string(e2_temp) = lambert93#
e2_temp = sp::spTransform(e2_temp, wgs84)#
e2_wgs84 = extent(e2_temp)#
#
	# A.2. Loading the rasters and shapefiles#
#
borders = shapefile("Raster_shapefiles/Borders_GADM_0_shapefile/Borders_GADM_0.shp")#
communes = shapefile("Raster_shapefiles/Belgian_communes_shapefile/Belgian_communes.shp")#
motorways = shapefile("Raster_shapefiles/Isolated_motorways_shapefile/Motorways_shapefile.shp")#
primaries = shapefile("Raster_shapefiles/Isolated_primary_roads_shp/Primary_roads.shp")#
fences_1 = shapefile("Raster_shapefiles/Clotures_20190731_shapefile/Clotures_20190731.shp")#
barriers = shapefile("Raster_shapefiles/Clotures_20190731_merged/Barriers_20190731.shp")#
clc_raster = raster("Raster_shapefiles/Corine_Land_Cover_original_file/Corine_Land_Cover.tif")#
forest_areas = raster("Raster_shapefiles/Corine_Land_Cover_rasters/Forest_areas.asc")#
agricultural_areas = raster("Raster_shapefiles/Corine_Land_Cover_rasters/Agricultural_areas.asc")#
artificial_areas = raster("Raster_shapefiles/Corine_Land_Cover_rasters/Artificial_areas.asc")#
land_cover = forest_areas; land_cover[agricultural_areas[]==1] = 2; land_cover[artificial_areas[]==1] = 3#
#
	# A.3. Uniformising the different projections#
#
crs(fences_1) = crs(communes)#
crs(barriers) = crs(fences_1)#
fences_2 = union(fences_1, barriers)#
belgium = crop(spTransform(belgium, lambert93), e1_lam93)#
borders = crop(spTransform(borders, lambert93), e1_lam93)#
communes = crop(spTransform(communes, lambert93), e1_lam93)#
motorways = crop(spTransform(motorways, lambert93), e1_lam93)#
primaries = crop(spTransform(primaries, lambert93), e1_lam93)#
fences_1 = crop(spTransform(fences_1, lambert93), e1_lam93)#
fences_2 = crop(spTransform(fences_2, lambert93), e1_lam93)#
fences_2 = union(fences_2, motorways)#
#
crs(forest_areas) = crs(clc_raster)#
crs(agricultural_areas) = crs(clc_raster)#
crs(artificial_areas) = crs(clc_raster)#
crs(land_cover) = crs(clc_raster)#
forest_areas = projectRaster(forest_areas, crs=lambert93)#
forest_areas = crop(forest_areas, e1_lam93); r = forest_areas#
forest_areas[] = (r[]-min(r[],na.rm=T))/(max(r[],na.rm=T)-min(r[],na.rm=T))#
forest_areas[] = round(forest_areas[]); names(forest_areas) = "forest_areas"#
agricultural_areas = projectRaster(agricultural_areas, crs=lambert93)#
agricultural_areas = crop(agricultural_areas, e1_lam93); r = agricultural_areas#
agricultural_areas[] = (r[]-min(r[],na.rm=T))/(max(r[],na.rm=T)-min(r[],na.rm=T))#
agricultural_areas[] = round(agricultural_areas[]); names(agricultural_areas) = "agricultural_areas"#
crs(forest_areas) = crs(lambert93); crs(agricultural_areas) = crs(lambert93)#
land_covers_3 = projectRaster(land_cover, crs=lambert93)#
land_covers_3 = crop(land_covers_3, e1_lam93); r = land_covers_3#
land_covers_3[] = ((r[]-min(r[],na.rm=T))/(max(r[],na.rm=T)-min(r[],na.rm=T)))*3#
land_covers_3[] = round(land_covers_3[]); crs(land_covers_3) = crs(lambert93)#
study_areas = forest_areas; study_areas[!is.na(study_areas[])] = 1#
#
# B.
library(doMC)#
library(fields)#
library(gdistance)#
library(geometry)#
library(ks)#
library(lubridate)#
library(maptools)#
library(OpenStreetMap)#
library(raster)#
library(RColorBrewer)#
library(rgdal)#
library(rgeos)#
library(sampSurf)#
library(seraphim)#
library(sp)#
library(spatstat)#
#
# A. Preparing the environmental data#
	# A.1. Defining the projections and extents#
	# A.2. Loading the rasters and shapefiles#
	# A.3. Uniformising the different projections#
	# A.4. Generating the overall European map#
# B. Analysing the GPS collar data#
	# B.1. Loading the GPS collar traces#
	# B.2. Visualising the GPS traces on OpenStreetMap#
	# B.3. Extracting environmental values and distances#
	# B.4. Analyses of the impact of factors on movement velocity#
	# B.5. Analysis of the time proportion spent in non-forest areas#
	# B.6. Estimating the frequency of crossing motorway events#
# C. Analysing the occurrence data#
	# C.1. Loading and preparing the reported cases#
	# C.2. Subsetting the data based on kernel densities#
	# C.3. Estimating and plotting the wavefront velocities#
		# C.3.1. Defining the analysis mask#
		# C.3.2. Interpolation of first time of invasion#
		# C.3.3. Estimating the friction and spread rate#
		# C.3.4. Estimating the spread rate#
		# C.3.5. Plotting the resulting rasters#
	# C.4. Investigating the impact of environmental factors on the dispersal#
		# C.4.1. Analysing the impact of factors on the wavefront dispersal velocity#
		# C.4.2. Analysis of the impact of barriers on the dispersal frequency#
showingPlots = FALSE#
#
# A. Preparing the environmental data#
#
	# A.1. Defining the projections and extents#
#
wgs84 = CRS("+init=epsg:4326")#
lambert72 = CRS("+init=epsg:31370")#
lambert93 = CRS("+init=epsg:2154")#
e1_lam93 = extent(760000, 950000, 6910000, 7080000)#
e1_temp = as(e1_lam93, "SpatialPolygons")#
sp::proj4string(e1_temp) = lambert93#
e1_temp = sp::spTransform(e1_temp, wgs84)#
e1_wgs84 = extent(e1_temp)#
e2_lam93 = extent(865000, 911000, 6935700, 6975000)#
e2_temp = as(e2_lam93, "SpatialPolygons")#
sp::proj4string(e2_temp) = lambert93#
e2_temp = sp::spTransform(e2_temp, wgs84)#
e2_wgs84 = extent(e2_temp)#
#
	# A.2. Loading the rasters and shapefiles#
#
borders = shapefile("Raster_shapefiles/Borders_GADM_0_shapefile/Borders_GADM_0.shp")#
communes = shapefile("Raster_shapefiles/Belgian_communes_shapefile/Belgian_communes.shp")#
motorways = shapefile("Raster_shapefiles/Isolated_motorways_shapefile/Motorways_shapefile.shp")#
primaries = shapefile("Raster_shapefiles/Isolated_primary_roads_shp/Primary_roads.shp")#
fences_1 = shapefile("Raster_shapefiles/Clotures_20190731_shapefile/Clotures_20190731.shp")#
barriers = shapefile("Raster_shapefiles/Clotures_20190731_merged/Barriers_20190731.shp")#
clc_raster = raster("Raster_shapefiles/Corine_Land_Cover_original_file/Corine_Land_Cover.tif")#
forest_areas = raster("Raster_shapefiles/Corine_Land_Cover_rasters/Forest_areas.asc")#
agricultural_areas = raster("Raster_shapefiles/Corine_Land_Cover_rasters/Agricultural_areas.asc")#
artificial_areas = raster("Raster_shapefiles/Corine_Land_Cover_rasters/Artificial_areas.asc")#
land_cover = forest_areas; land_cover[agricultural_areas[]==1] = 2; land_cover[artificial_areas[]==1] = 3#
#
	# A.3. Uniformising the different projections#
#
crs(fences_1) = crs(communes)#
crs(barriers) = crs(fences_1)#
fences_2 = union(fences_1, barriers)#
belgium = crop(spTransform(belgium, lambert93), e1_lam93)#
borders = crop(spTransform(borders, lambert93), e1_lam93)#
communes = crop(spTransform(communes, lambert93), e1_lam93)#
motorways = crop(spTransform(motorways, lambert93), e1_lam93)#
primaries = crop(spTransform(primaries, lambert93), e1_lam93)#
fences_1 = crop(spTransform(fences_1, lambert93), e1_lam93)#
fences_2 = crop(spTransform(fences_2, lambert93), e1_lam93)#
fences_2 = union(fences_2, motorways)#
#
crs(forest_areas) = crs(clc_raster)#
crs(agricultural_areas) = crs(clc_raster)#
crs(artificial_areas) = crs(clc_raster)#
crs(land_cover) = crs(clc_raster)#
forest_areas = projectRaster(forest_areas, crs=lambert93)#
forest_areas = crop(forest_areas, e1_lam93); r = forest_areas#
forest_areas[] = (r[]-min(r[],na.rm=T))/(max(r[],na.rm=T)-min(r[],na.rm=T))#
forest_areas[] = round(forest_areas[]); names(forest_areas) = "forest_areas"#
agricultural_areas = projectRaster(agricultural_areas, crs=lambert93)#
agricultural_areas = crop(agricultural_areas, e1_lam93); r = agricultural_areas#
agricultural_areas[] = (r[]-min(r[],na.rm=T))/(max(r[],na.rm=T)-min(r[],na.rm=T))#
agricultural_areas[] = round(agricultural_areas[]); names(agricultural_areas) = "agricultural_areas"#
crs(forest_areas) = crs(lambert93); crs(agricultural_areas) = crs(lambert93)#
land_covers_3 = projectRaster(land_cover, crs=lambert93)#
land_covers_3 = crop(land_covers_3, e1_lam93); r = land_covers_3#
land_covers_3[] = ((r[]-min(r[],na.rm=T))/(max(r[],na.rm=T)-min(r[],na.rm=T)))*3#
land_covers_3[] = round(land_covers_3[]); crs(land_covers_3) = crs(lambert93)#
study_areas = forest_areas; study_areas[!is.na(study_areas[])] = 1#
#
# B. Analysing the GPS collar data
if (!file.exists("GSP_collar_2.csv"))#
	{#
		gps = read.csv("GSP_collar_1.csv") # removing outliers:#
		gps = gps[which(gps[,"gps_validity_code"]==1),]#
		times = matrix(nrow=dim(gps)[1], ncol=1)#
		colnames(times) = "time"#
		for (i in 1:dim(gps)[1])#
			{#
				time = as.character(gps[i,"acquisition_time"])#
				if ((!is.na(time))&&(time != "\\N"))#
					{#
						time = unlist(strsplit(time," "))#
						day1 = decimal_date(ymd(time[1]))#
						hours1 = unlist(strsplit(gsub("\\+00","",time[2]),":"))#
						day2 = ((as.numeric(hours1[1])/24)/365) + (((as.numeric(hours1[2])/60)/24)/365) + ((((as.numeric(hours1[3])/60)/60)/24)/365)#
						time = day1+day2; times[i,1] = time#
					}	else	{#
						times[i,1] = NA#
					}#
			}#
		gps = cbind(gps, times)#
		gps = gps[!is.na(gps[,"time"]),]#
		gps = gps[!is.na(gps[,"longitude"]),]#
		gps = gps[!is.na(gps[,"latitude"]),]#
		temp1 = gps[,c("longitude","latitude")]#
		coordinates(temp1) = ~ longitude + latitude; crs(temp1) = wgs84#
		temp2 = spTransform(temp1, lambert93)#
		gps$x_lambert93 = temp2@coords[,1]#
		gps$y_lambert93 = temp2@coords[,2]#
		temp3 = spTransform(temp1, osm())#
		gps$x_openStreetMap = temp3@coords[,1]#
		gps$y_openStreetMap = temp3@coords[,2]#
		write.csv(gps, "GSP_collar_2.csv", row.names=F, quote=F)#
	}#
#
	# B.2. Visualising the GPS traces on OpenStreetMap#
#
gps = read.csv("GSP_collar_2.csv"); individuals = list(); individual_names = list()#
individual_ids = unique(gps[,"animals_original_id"])#
for (i in 1:length(individual_ids))#
	{#
		lines = which(gps[,"animals_original_id"]==individual_ids[i])#
		individual = gps[lines,c("time","longitude","latitude","x_lambert93","y_lambert93","x_openStreetMap","y_openStreetMap")]#
		individual = individual[order(individual[,"time"]),]#
		individual_name = paste(gps[lines[1],"short_name"],gps[lines[1],"animals_original_id"],sep="_")#
		if (individual_ids[i] == "su398bleu2005")#
			{#
				index = which(individual[,"time"]==2006.41495494039)#
				individual = individual[-index,] # to manually remove a remaining outlier#
			}#
		write.csv(individual, paste0("GSP_collar_data/",individual_name,".csv"), row.names=F, quote=F)#
		individuals[[i]] = individual; individual_names[[i]] = individual_name#
	}#
upperLeft = c(e1_wgs84@ymax,e1_wgs84@xmin); lowerRight=c(e1_wgs84@ymin,e1_wgs84@xmax)#
openStreetMap = openmap(upperLeft, lowerRight, type="osm", zoom=9); OSMap = TRUE#
for (i in 1:length(individuals))#
	{#
		if (!file.exists(paste0("GSP_collar_data/",individual_names[[i]],".pdf")))#
			{#
				if (OSMap == TRUE)#
					{#
						pdf(paste0("GSP_collar_data/",individual_names[[i]],".pdf"), width=6.0, height=5.5)#
						r = raster(openStreetMap); # dev.new(width=6.0, height=5.5)#
						par(mar=c(0,0,0,0), oma=c(0,2,0,2), mgp=c(0,0.4,0), lwd=0.2, bty="o")#
						plot(openStreetMap)#
						for (j in 2:dim(individuals[[i]])[1])#
							{#
								pts = cbind(individuals[[i]][j-1,c("x_openStreetMap")],individuals[[i]][j-1,c("y_openStreetMap")])#
								pts = rbind(pts,cbind(individuals[[i]][j,c("x_openStreetMap")],individuals[[i]][j,c("y_openStreetMap")]))#
								lines(pts, lwd=0.3, col="gray10")#
							}#
					}	else	{#
						pdf(paste0(individual_names[[i]],".pdf"), width=6.0, height=5.5)#
						r = forest_areas; # dev.new(width=6.0, height=5.5)#
						par(mar=c(0,4,0,0), oma=c(0,0,0,0), mgp=c(0,0.4,0), lwd=0.2, bty="o")#
						plot(forest_areas, col=c(rgb(0,1,0,0),rgb(68/255,165/255,68/255,0.3)), box=F, axes=F, legend=F)#
						plot(belgium, add=T, lwd=1.0, border="white", lty=1)#
						plot(belgium, add=T, lwd=0.25, border="gray30", lty=1)#
						plot(motorways, add=T, lwd=0.75, col="red", lty=1)#
						for (j in 2:dim(individuals[[i]])[1])#
							{#
								pts = cbind(individuals[[i]][j-1,c("x_lambert93")],individuals[[i]][j-1,c("y_lambert93")])#
								pts = rbind(pts,cbind(individuals[[i]][j,c("x_lambert93")],individuals[[i]][j,c("y_lambert93")]))#
								lines(pts, lwd=0.3, col="gray10")#
							}#
					}#
				rect(xmin(r), ymin(r), xmax(r), ymax(r), xpd=T, lwd=0.2, border="gray30")#
				dev.off()#
			}#
	}#
if (!file.exists(paste0("GSP_data_2.pdf")))#
	{#
		l = length(individuals); p = round(length(individuals)/3)+1; OSMap = FALSE#
		cols = colorRampPalette(brewer.pal(11,"Spectral"))(l+p)[c(1:(l/2),((l/2)+p):(l+p))]#
		if (OSMap == TRUE)#
			{#
				pdf(paste0("GSP_data_2.pdf"), width=6.0, height=5.5)#
				r = raster(openStreetMap); # dev.new(width=6.0, height=5.5)#
				par(mar=c(0,0,0,0), oma=c(0,2,0,2), mgp=c(0,0.4,0), lwd=0.2, bty="o")#
				plot(openStreetMap)#
				for (i in 1:length(individuals))#
					{#
						for (j in 2:dim(individuals[[i]])[1])#
							{#
								pts = cbind(individuals[[i]][j-1,c("x_openStreetMap")],individuals[[i]][j-1,c("y_openStreetMap")])#
								pts = rbind(pts,cbind(individuals[[i]][j,c("x_openStreetMap")],individuals[[i]][j,c("y_openStreetMap")]))#
								lines(pts, lwd=0.3, col="gray10")#
							}#
					}#
				rect(xmin(r), ymin(r), xmax(r), ymax(r), xpd=T, lwd=0.2, border="gray30")#
			}	else 	{#
				pdf(paste0(individual_names[[i]],".pdf"), width=6.0, height=5.5)#
				r = forest_areas; # dev.new(width=6.0, height=5.5)#
				par(mar=c(0,4,0,0), oma=c(0,0,0,0), mgp=c(0,0.4,0), lwd=0.2, bty="o")#
				plot(land_covers_3, col=c(rgb(0,1,0,0),rgb(68/255,165/255,68/255,0.2),rgb(0,1,0,0),"gray80"), box=F, axes=F, legend=F)#
				plot(borders, add=T, lwd=3, col="white", lty=1)#
				plot(borders, add=T, lwd=0.5, col="blue")#
				plot(motorways, add=T, lwd=0.75, col="red", lty=1)#
				for (i in 1:length(individuals))#
					{#
						GPS_segments = cbind(individuals[[i]][2:dim(individuals[[i]])[1],4:5],individuals[[i]][1:dim(individuals[[i]])[1]-1,4:5])#
						segments(GPS_segments[,1],GPS_segments[,2],GPS_segments[,3],GPS_segments[,4], lwd=0.3, col="gray10")#
					}#
				points(data1[,c("x_transformed","y_transformed")], cex=0.5,  lwd=0.5, pch=3, col="green3")#
				segments(e2_lam93@xmin, e2_lam93@ymin, e2_lam93@xmax, e2_lam93@ymin, col="gray30", lwd=0.75, lty=1)#
				segments(e2_lam93@xmax, e2_lam93@ymin, e2_lam93@xmax, e2_lam93@ymax, col="gray30", lwd=0.75, lty=1)#
				segments(e2_lam93@xmax, e2_lam93@ymax, e2_lam93@xmin, e2_lam93@ymax, col="gray30", lwd=0.75, lty=1)#
				segments(e2_lam93@xmin, e2_lam93@ymax, e2_lam93@xmin, e2_lam93@ymin, col="gray30", lwd=0.75, lty=1)#
				rect(xmin(r), ymin(r), xmax(r), ymax(r), xpd=T, lwd=0.2, border="gray30")#
			}#
		dev.off()#
	}#
#
	# B.3. Extracting environmental values and distances
data1 = read.csv("Data_130919.csv", header=T); maxDays = max(data1[,"days"])#
temp1 = data1; coordinates(temp1) = ~ longitude + latitude; crs(temp1) = wgs84#
myOutProj = CRS("+proj=lcc +lat_1=18 +lat_2=24 +lat_0=21 +lon_0=114 +x_0=500000 +y_0=500000 #
				 +ellps=WGS72 +towgs84=0,0,1.9,0,0,0.814,-0.38 +units=m +no_defs") # not used#
temp2 = spTransform(temp1, lambert93)#
data1$x_transformed = temp2@coords[,1]#
data1$y_transformed = temp2@coords[,2]
data2 = read.csv("Data_KDE_95.csv", header=T)#
template = forest_areas; template[!is.na(template[])] = 0#
H = Hpi(data2[,c("x_transformed","y_transformed")])#
kde = kde(data2[,c("x_transformed","y_transformed")], H=H, compute.cont=T, gridsize=c(1000,1000))#
rast1 = raster(kde); contour = rasterToContour(rast1, levels=kde$cont["5%"])#
threshold = min(raster::extract(rast1, data2[,c("x_transformed","y_transformed")]))#
rast2 = rast1; rast2[rast1[]<=threshold] = NA # previous version to include all points#
p = Polygon(contour@lines[[1]]@Lines[[1]]@coords); ps = Polygons(list(p),1); sps = SpatialPolygons(list(ps))#
rast2 = mask(rast1, sps); mask = raster::resample(rast2, template)#
#
		# C.3.2. Interpolation of first time of invasion
